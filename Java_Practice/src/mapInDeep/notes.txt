The Java Collections Framework provides a set of interfaces (like List, Set, and Map)
and a set of classes (ArrayList, HashSet, HashMap, etc.) that implement those interfaces.
All of these are part of the java.util package.

Interfaces like List define what tools can do,
and classes like ArrayList are the actual tools that do the work.


            Iterable
                │
          ┌─────┴──────┐
          │            │
      Collection       Map
          │
  ┌───────┼────────┐
  │       │        │
 List     Set     Queue


Iterable – The root interface that lets you use the enhanced for loop (for-each).

Collection – The root interface for groups of objects (called elements).

List, Set, Queue – Subinterfaces of Collection, defining different rules for storing elements.

Map – A separate hierarchy for key–value pairs (not part of Collection).


Interface       Classes        Description
---------       ------------   ---------------------------------------------------------
List	        ArrayList	   Resizable array that maintains order and allows duplicates
                LinkedList	   List with fast insert and remove operations

Set	            HashSet	       Unordered collection of unique elements
                TreeSet	       Sorted set of unique elements (natural order)
                LinkedHashSet  Maintains the order in which elements were inserted


Map	            HashMap	       Stores key/value pairs with no specific order
                TreeMap	       Sorted map based on the natural order of keys
                LinkedHashMap  Maintains the order in which keys were inserted


HashMap → Hash table + linked list/tree for collisions

Converts key’s hashCode into a bucket index.
Stores key-value pairs in that bucket (linked list or balanced tree if too many collisions).
Best for fast lookups and inserts — average O(1).


LinkedHashMap → HashMap + doubly linked list

Same hashing logic as HashMap.
Keeps a doubly linked list to remember insertion order (or access order if LRU mode).
Perfect when we need predictable iteration order (like recent-activity caches).



TreeMap → Red-Black Tree (sorted tree)
Stores keys in a self-balancing binary tree.
Automatically keeps entries sorted by key (natural/comparator).
Great when we need sorted maps — but O(log n) for all operations.



Hashtable → Old synchronized hash table
Works like HashMap but all methods are synchronized → only one thread can access it at a time.
Slower, doesn’t allow nulls. Used in legacy code, not modern systems.


ConcurrentHashMap → Modern segmented hash table
Divides the table into multiple smaller buckets (“segments”) with independent locks.
Multiple threads can read/write simultaneously.
Best for high-concurrency, thread-safe environments like web servers or ERP modules running in parallel.

